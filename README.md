# 该仓库用于记录c++学习过程中的重点
## day01

**命名空间**
   
    最好是不要一次性全部引入，用什么引入什么。

**跨模块调用**
   
    1.用于代码结构简单的。
    2.静态变量只在本模块起作用

**const常量和宏定义常量的区别**
   
    1.时机不同，宏定义时在预处理时进行字符串替换,const是在编译时。
    2.宏定义没有类型。

**const与指针**
   
    1.const int *p(常量指针,指向一个常量的指针)  const在*号前：不能改指针所指向的值,但是可以更改指向
    2.int * const p(指针常量,一个指针类型的常量) const在*号后：不能改指向，但是可以改指向的值
    
## day02
**函数返回引用类型**
   
    1.不要返回局部变量的引用
    2.不要轻易返回堆空间的引用（容易造成内存泄漏）

**C++风格的类型强制转换**
   
    1.int *p = static_cast<int*>(malloc(sizeof(int)));
    2.与c相比：可以检查是否可以强制转换且便于查找

**函数的默认参数**
   
    1.可以在函数声明时在函数形参赋值  int add(int x = 0, int y = 0);
    2.也可以在函数定义时(最常用)

## day03
**C++中类和结构体的区别**

    1.类中的成员默认私有，结构体中默认时公有

**类与多文件联合编译**

    1.成员函数定义在类中的头文件可以被多个源文件引入，因为默认认为类中的函数为inline函数
    2.函数声明放头文件，函数实现放在源文件（最常见方式）

**构造函数**

    1.编译器会自动生成无参构造函数

**初始化列表**
    
    1.构造函数(值1, 值2...):属性1(值1),属性2(值2)...{}
    2.成员属性的初始化顺序取决于，类中声明的顺序，而非构造时的顺序
    3.构造函数的实现也可以在类内声明类外实现

**析构函数**

    1.~类名(){}
    2.对象被销毁时会自动调用析构函数
    3.析构函数只是提供了释放堆空间的接口，需要自己完成析构函数内部
    4.如果类中的数据成员没有指针，即没有在堆上申请空间，默认的析构函数就够用了
    5.如果没有进行安全回收(nullptr)多次调用析构函数，会发生错误(double free)
    6.不建议手动调用析构函数
    7.对象被销毁一定会调用析构函数，但是在销毁前调用析构函数（手动）对象并不会被销毁。

**拷贝构造函数**

    1.用一个已存在的对象去初始化创建一个新的对象
    2.编译器会自动提供拷贝构造函数
    3.注意区分浅拷贝（可能发生double free）和深拷贝
    4.如果类中成员变量有指针需要在堆空间申请内存，必须要深拷贝
    5.函数传参为对象时，若值传递传参，会调用拷贝构造函数，所以最好使用引用传递
    6.用初始化列表的形式去实现拷贝构造函数

##day04

**赋值运算符函数**

    1.用一个已存在的对象去覆盖另一个已存在的对象的数据
    2.编译器会自动提供一个默认的赋值运算符函数
    3.Point & operator=(const Point & p){}
    4.若成员变量有指针，使用自带的赋值函数时同样会出现double free问题，需要自己重新实现
    5.做深拷贝时，注意没存泄露

**this指针**

    1.this指针的本质--指针常量Type * const pointer
    2.this指针指向本对象

**特殊数据成员**

    1.const常量成员：用初始化列表，c++11中可以在声明时赋值
    2.引用数据成员：也是在初始化列表中初始化，要确保绑定的时一个左值(确定值)
    3.对象成员：必须用初始化列表初始化，若初始化列表没有显示的初始化对象成员，编译器会自动调用对象的无参构造。
    4.静态数据成员：该成员在编译阶段就被分配内存，所有对象共享一份数据，类内声明类外初始化

**特殊成员函数**

    1.静态成员函数：所有对象共享一个静态函数，只能访问静态数据成员。可以不通过对象用类名::来调用
    2.常函数(const)：该函数中不能对成员变量进行修改(原理： const Person * const this),若不对成员变量进行修改就统统定义为常函数

**特殊对象**

    1.常对象(const)：常对象只能调用常函数，但是普通对象也能调用常函数。

**单例模式（重点）**

    1.静态对象方式：利用了静态的局部对象只会被初始化一次的特性，缺点是全局/局部空间有限
    2.堆上创建对象的方式：关键在于用一个静态对象指针来接收new出来的对象，便于判断是否为空，若非空则不new直接返回
    需要再写一个静态函数来释放堆上的对象，而不是改写析构函数。

##day05

**String类**


##day06

**Vector**
    
**标准输出流**

    1.若输入的类型不一致，会将原来的数据改为0：如int num = 10; cin >> num; "键盘输入abc" cout << num; 结果为0，并且"abc"还留在缓冲区

##day07

**友元**

    1.用friend关键字声明友元
    2.前向声明的用处：进行了前向声明的类，可以以引用或指针的形式作为函数的参数，只要不涉及堆该类对象具体成员的访问，编译器可以通过
    3.友元类（常用）：方便，但是友元类可以修改类中的成员。

**运算符重载**

    1.运算符重载时不能设置默认值，这会改变参数的个数
    2.三种形式：友元函数（常见）、普通函数（失去了对私有成员的保护）、成员函数（常见）



