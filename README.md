# 该仓库用于记录c++学习过程中的重点
## day01

**命名空间**
   
    最好是不要一次性全部引入，用什么引入什么。

**跨模块调用**
   
    1.用于代码结构简单的。
    2.静态变量只在本模块起作用

**const常量和宏定义常量的区别**
   
    1.时机不同，宏定义时在预处理时进行字符串替换,const是在编译时。
    2.宏定义没有类型。

**const与指针**
   
    1.const int *p(常量指针,指向一个常量的指针)  const在*号前：不能改指针所指向的值,但是可以更改指向
    2.int * const p(指针常量,一个指针类型的常量) const在*号后：不能改指向，但是可以改指向的值
    
## day02
**函数返回引用类型**
   
    1.不要返回局部变量的引用
    2.不要轻易返回堆空间的引用（容易造成内存泄漏）

**C++风格的类型强制转换**
   
    1.int *p = static_cast<int*>(malloc(sizeof(int)));
    2.与c相比：可以检查是否可以强制转换且便于查找

**函数的默认参数**
   
    1.可以在函数声明时在函数形参赋值  int add(int x = 0, int y = 0);
    2.也可以在函数定义时(最常用)

## day03
**C++中类和结构体的区别**

    1.类中的成员默认私有，结构体中默认时公有

**类与多文件联合编译**

    1.成员函数定义在类中的头文件可以被多个源文件引入，因为默认认为类中的函数为inline函数
    2.函数声明放头文件，函数实现放在源文件（最常见方式）

**构造函数**

    1.编译器会自动生成无参构造函数

**初始化列表**
    
    1.构造函数(值1, 值2...):属性1(值1),属性2(值2)...{}
    2.成员属性的初始化顺序取决于，类中声明的顺序，而非构造时的顺序
    3.构造函数的实现也可以在类内声明类外实现

**析构函数**

    1.~类名(){}
    2.对象被销毁时会自动调用析构函数
    3.析构函数只是提供了释放堆空间的接口，需要自己完成析构函数内部
    4.如果类中的数据成员没有指针，即没有在堆上申请空间，默认的析构函数就够用了
    5.如果没有进行安全回收(nullptr)多次调用析构函数，会发生错误(double free)
    6.不建议手动调用析构函数
    7.对象被销毁一定会调用析构函数，但是在销毁前调用析构函数（手动）对象并不会被销毁。

**拷贝构造函数**

    1.编译器会自动提供拷贝构造函数
    2.注意区分浅拷贝（可能发生double free）和深拷贝
    3.如果类中成员变量有指针需要在堆空间申请内存，必须要深拷贝
    4.函数传参为对象时，若值传递传参，会调用拷贝构造函数，所以最好使用引用传递




















